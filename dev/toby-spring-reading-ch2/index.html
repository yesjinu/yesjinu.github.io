<!DOCTYPE html>
<html lang="en" class="astro-GU7EB2LC">
	<head>
		<!-- Global Metadata --><meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<link rel="icon" type="image/svg+xml" href="/favicon.svg">
<meta name="generator" content="Astro v1.9.2">

<!-- Canonical URL -->
<link rel="canonical" href="https://yesjinu.github.io/dev/toby-spring-reading-ch2/">

<!-- Primary Meta Tags -->
<title>토비의 스프링 2장, 테스트</title>
<meta name="title" content="토비의 스프링 2장, 테스트">
<meta name="description">

<!-- Open Graph / Facebook -->
<meta property="og:type" content="website">
<meta property="og:url" content="https://yesjinu.github.io/dev/toby-spring-reading-ch2/">
<meta property="og:title" content="토비의 스프링 2장, 테스트">
<meta property="og:description">
<meta property="og:image" content="https://yesjinu.github.io/placeholder-social.jpg">

<!-- Twitter -->
<meta property="twitter:card" content="summary_large_image">
<meta property="twitter:url" content="https://yesjinu.github.io/dev/toby-spring-reading-ch2/">
<meta property="twitter:title" content="토비의 스프링 2장, 테스트">
<meta property="twitter:description">
<meta property="twitter:image" content="https://yesjinu.github.io/placeholder-social.jpg">

		
	<link rel="stylesheet" href="/assets/about.ec6472ad.css" /></head>

	<body class="astro-GU7EB2LC">
		<header class="astro-QTG6CBMA">
	<h2 class="astro-QTG6CBMA">
		Here&#39;s my dents in the universe
	</h2>
	<nav class="astro-QTG6CBMA">
		<a href="/" class="astro-QTG6CBMA astro-MIGJJ2DC">
	Home
</a>

		<a href="/dev" class="astro-QTG6CBMA astro-MIGJJ2DC">
	Dev
</a>

		<a href="/life" class="astro-QTG6CBMA astro-MIGJJ2DC">
	Life
</a>

		<a href="/about" class="astro-QTG6CBMA astro-MIGJJ2DC">
	About
</a>

	</nav>
</header>

		<main class="astro-GU7EB2LC">
			<article class="astro-GU7EB2LC">
				
				<h1 class="title astro-GU7EB2LC">토비의 스프링 2장, 테스트</h1>
				<time class="astro-GU7EB2LC">2022-09-18T00:50:44.000Z</time>
				
				<hr class="astro-GU7EB2LC">
				<h2 id="스프링과-테스트">스프링과 테스트</h2>
<p>스프링이 개발자에게 제공하는 가장 중요한 가치는 <code>객체지향</code>과 <code>테스트</code>다. 현대의 앱은 계속 변하고 복잡해져가기 때문에 이 두 가지 무기를 잘 사용하는 것이 좋다.</p>
<ol>
<li>IoC/DI : 오브젝트의 설계, 생성, 관계, 사용에 관한 기술. 객체지향을 이용해 복잡한 엔터프라이즈 앱을 효과적으로 개발할 수 있게 한다.</li>
<li>테스트 : 만들어진 코드에 확신을, 변화에는 대처할 수 있는 자신감을 준다.</li>
</ol>
<h2 id="수동-테스트의-한계">수동 테스트의 한계</h2>
<p>1장에서는 <code>public static void main</code> 메서드를 통해 클래스의 메서드를 직접 실행해보고 확인하는 방식으로 테스트를 진행했다. 하지만 여기에는 2가지 한계가 존재한다.</p>
<ol>
<li>실행의 번거로움 : 테스트하고자 하는 클래스가 여러 개 되면 어떻게 할 것인가? 일일이 찾아다니며 main 메서드를 실행할 것인지?</li>
<li>확인의 번거로움 : 실행 결과를 정답값과 직접 눈으로 비교해야한다. 비교해야하는 값이 수천 가지가 넘는데 가능할까?</li>
</ol>
<h2 id="테스트-자동화">테스트 자동화</h2>
<p><code>JUnit</code>이라는 테스팅 프레임워크를 사용해 테스트를 진행할 것. 이 프레임워크를 사용하면 수동 테스트의 한계에서 지적했던 테스트를 실행하고 확인하는 과정을 자동화할 수 있다. 프레임워크의 기본 동작 원리는 IoC/DI. 개발자가 만든 클래스의 오브젝트를 생성하고 실행하는 일은 프레임워크에 의해 진행된다. JUnit 프레임워크가 요구하는 조건은 2가지.</p>
<ol>
<li>메소드가 public으로 선언되어야</li>
<li>메소드에 <code>@Test</code> 어노테이션을 붙여주어야</li>
</ol>
<h2 id="몇-가지-새로-알게-된-사실">몇 가지 새로 알게 된 사실</h2>
<h3 id="1-junit이-테스트를-수행하는-순서">1) JUnit이 테스트를 수행하는 순서</h3>
<p>JUnit이 하나의 테스트 클래스를 가져와 테스트를 수행하는 방식은 다음과 같다.</p>
<ol>
<li>테스트 클래스에서 @Test가 붙은 public, void, 파라미터 없는 테스트 메소드를 모두 찾는다.</li>
<li>테스트 클래스 오브젝트를 하나 만든다.</li>
<li>@Befor가 붙은 메소드가 있으면 실행한다.</li>
<li>@Test가 붙은 메소드를 하나 호출하고 테스트 결과를 저장해둔다.</li>
<li>@After가 붙은 메소드가 있으면 실행한다.</li>
<li>나머지 테스트 메소드에 대해 2~5번을 반복한다.</li>
<li>모든 테스트의 결과를 종합해서 돌려준다.</li>
</ol>
<p>따라서 모든 테스트는 다른 테스트와 격리된 상태로 돌아간다. @Before에서 실행되는 setUp 코드 역시 매 테스트마다 새로 수행되므로 더 정확하게는 BeforeEach와 같은 역할을 한다고 할 수 있다.</p>
<h3 id="2-autowired가-빈을-찾는-순서">2) <code>@Autowired</code>가 빈을 찾는 순서</h3>
<p><code>@Autowired</code>가 붙은 인스턴스 변수가 있으면, 컨텍스트 프레임워크는 변수 타입과 일치하는 컨텍스트 내 빈을 찾는다. 타입이 일치하는 빈이 있으면 인스턴스 변수에 주입해준다. 그렇다면 같은 타입의 빈이 2개 이상 있는 경우에는 어떻게 할까? 이럴 때에는 변수의 이름과 같은 이름의 빈이 있는지 확인한다. 변수 이름으로도 빈을 찾을 수 없는 경우에는 예외가 발생한다.</p>
<ol>
<li>타입으로 찾고</li>
<li>이름으로 찾고</li>
</ol>
			</article>
		</main>
		<footer class="astro-GU32XT2E">
	&copy; 2020-2023 Jinu Noh. All rights reserved.
</footer>

	</body></html>