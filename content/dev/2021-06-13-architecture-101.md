---
title: 번역 웹 아키텍쳐 101
slug: architecture-101
date_published: 2021-06-13T10:56:00.000Z
date_updated: 2021-11-11T00:28:04.000Z
---

> 내가 웹 개발자로 일하기 시작했을 때 알았다면 좋았을 것들

원문 링크 - [Web Architecture 101](https://medium.com/storyblocks-engineering/web-architecture-101-a3224e126947)
![image](__GHOST_URL__/content/images/2021/11/Untitled.png)
위 다이어그램은 Storyblocks 웹사이트 아키텍쳐에 대한 좋은 구조도 입니다. 만약 당신이 숙련된 웹 개발자가 아니라면, 위 그림이 매우 복잡하게 보일 것입니다. 각 컴포넌트의 세부사항으로 들어가기 전에 아래의 이야기를 읽고 나면 이해하는 데에 큰 도움이 될 것입니다.

> 한 유저가 구글에 "안개가 자욱한 숲 속에 내리쬐는 햇볕"을 검색합니다. 첫번째로 제시된 결과물이 Storyblocks 웹사이트로부터 나온 것이었다고 합시다. (Storyblocks는 사진과 벡터 이미지를 제공하는 웹사이트 입니다.) 유저가 웹사이트 링크를 클릭하면 브라우저는 해당 이미지의 상세 페이지로 이동하게 됩니다. 유저의 브라우저는 DNS로 Storyblocks의 ip 주소를 찾는 요청(request)를 보내고, 이에 대한 응답(response, ip address) 주소로 다시 웹페이지에 대한 요청을 보냅니다.

이 요청은 우리의 부하 분산기(load balancer)에 먼저 도착하게 되고, 부하 분산기는 우리가 요청을 처리하기 위해 운영하고 있는 10개 정도의 웹 서버 중 하나를 골라줍니다. 웹서버는 캐시와 데이터베이스를 뒤져 유저가 요청한 이미지를 찾습니다. 만약 유저가 찾는 이미지에 대한 color profile이 아직 계산되어 있지 않다면 업무 큐(job queue)에 color profile을 계산하라는 잡을 등록해 놓습니다. job 서버는 비동기적으로 결과를 데이터베이스에 업데이트할 것입니다.

다음으로, 우리는 요청받은 사진과 비슷한 사진을 찾기 위해 full text search service에 비슷한 사진을 찾아달라는 요청을 보내놓습니다. 유저가 Storyblocks에 로그인 할 경우, account service를 통해 유저의 계정 정보를 찾아봅니다. 마지막으로 우리는 page view event에 대한 정보를 data firehose로 보내 cloud storage system에 기록하도록 하고, 결국에는 data warehouse에 저장되도록 합니다. 이 정보는 후에 데이터 분석가들에 의해 분석될 예정입니다.

서버는 이제 view를 HTML로 렌더링해, 부하 분산기를 거쳐, 유저의 브라우저로 전송합니다. JS나 CSS 에셋을 포함한 페이지는 cloud storage system에 저장되어 있고, 유저의 브라우저는 다시 CDN에 컨택해 이 정보를 받아옵니다. 브라우저는 이 정보를 활용해 유저가 볼 페이지를 렌더링합니다.

다음으로 각 컴포넌트에 대한 보다 상세한 정보를 알아보도록 하겠습니다. 101 수업처럼 이 정보들이 당신의 머릿속에 웹 아키텍쳐에 대한 좋은 구조도를 만들어줄 겁니다.

### 1. DNS

DNS는 "Domain Name Service"의 약자이고, 이것은 world wide web을 가능하게 하는 backbone 기술입니다. 가장 기본적인 레벨의 DNS는 도메인 이름(`google.com`) - IP 주소(`85.192.83.19`)에 대한 key/value lookup을 제공합니다. 이 정보는 당신의 컴퓨터가 리퀘스트를 적절한 서버로 보내려할 때 필요하죠. 전화번호에 비유하자면, 도메인 이름과 IP 주소는 "노진우에게 전화하기"와 "010-9282-8753으로 전화"와 같습니다. 예전에는 누군가에게 전화를 걸기 전에 전화번호북을 뒤져야했던 것처럼, 당신은 도메인 이름에 맞는 IP 주소를 찾기 위해 DNS를 뒤져야 합니다. DNS를 인터넷의 전화번호북이라고 생각해도 좋아요.

훨씬 더 상세한 디테일이 많지만 101 수업에는 중요하지 않으므로 여기에서 넘어가겠습니다.

### 2. Load Balancer

부하 분산에 대해 알아보기 전에, 먼저 수평적 vs 수직적 어플리케이션 스케일링에 대해 알아볼 필요가 있습니다. 도대체 이 둘의 차이는 무엇일까요? 스택오버플로우의 답변을 달아두겠습니다 수평적 스케일링은 기기의 대수를 늘리는 것이고, 수직적 스케일링은 기기의 스펙(e.g., CPU, RAM)을 높이는 것입니다.

웹 개발을 하면서 당신은 (아마) 항상 수평적 스케일링이 필요할 것입니다. 왜냐하면 물건들은 항상 고장나기 마련이기 때문이죠. 서버, 네트워크는 무작위로 망가집니다.데이터 센터 전체가 갑자기 오프라인이 되어버리는 일도 있지요. 여러 대의 서버를 운영하는 것은, 정전 등의 사태로 서버가 꺼지는 것을 막는 훌륭한 대책이 되고, 어플리케이션이 끊임없이 돌아갈 수 있도록 돕습니다. 다른 말로, 당신의 프로그램이 오류에 더 잘 버티게 되는 것이죠. 둘째로, 수평적 스케일링은 당신의 어플리케이션 백엔드(웹 서버, 데이터베이스, etc.)가 서로 다른 서버에서 실행되게 함으로써, 최소한으로 결합할 수 있도록 합니다. 지구상의 어느 컴퓨터도 단 한 대만으로 당신의 모든 어플리케이션을 실행할만큼 성능이 좋을 수는 없습니다. Storyblock은 거의 모든 시간대에 150개에서 400개의 AWS EC2 인스턴스를 구동하고 있습니다. 모든 연산 파워를 수직적 스케일링으로 구현하기란 어려운 일입니다.

다시 부하 분산기으로 돌아가죠. 부하 분산기는 수평적 분산을 가능하게 하는 마법과도 같은 방법입니다. 부하 분산기로 들어온 요청은 수많은 어플리케이션 서버 중 하나로 전달됩니다. 어플리케이션 서버들은 모두 서로의 클론이자 미러 이미지이죠. 그들은 모두 같은 방식으로 동작하기 때문에 부하 분산기가 어느 서버를 선택하든지 그것은 그저 요청을 분배하는 효과를 지닙니다. 어느 서버 하나가 너무 많은 부하를 받지 않도록 말이죠.

바로 그겁니다. 컨셉상으로, 부하분산기는 매우 직관적이죠. 물론 그 이면에는 분명 복잡한 것들이 존재합니다만, 101에서 더이상 깊게 다루지는 않겠습니다.

### 3. Web Application Servers

하이 레벨에서의 웹 에플레이케이션 서버는 상대적으로 설명하기 쉽습니다. 그들은 비즈니스 핵심 로직을 실행합니다. 유저들의 요청을 핸들링해, 브라우저로 HTML을 회신하는 것들 말이죠. 그 작업을 수행하기 위해, 그것들은 통상적으로 백엔드 인프라스트럭쳐의 많은 부분과 소통해야 합니다. 예를들어 데이터베이스, 캐시, 잡 큐, 검색 서비스, 다른 마이크로 서비스, 데이터/로깅 큐와 같은 것들이 그것입니다. 위에서 언급한 것처럼, 당신은 유저들의 요청을 처리하기 위해 최소 2개에서 훨씬 더 많은 서버들을 운영할 것입니다.

앱 서버를 구현하기 위해서는 특정한 언어(Node.js, Ruby, PHP, Scala, Java, C#, .Net, etc.)와 그게 맞는 웹 MVC 프레임워크(Express for Node,js, Ruby on Rails, Play for Scala, Laravel for PHP, etc.)를 선택해야 합니다. 더 이상의 세부사항은 이 아티클의 범위를 넘어섭니다.

### 4. Database Servers

현대의 모든 웹 어플리케이션은 한 개 이상의 데이터베이스를 사용해 정보를 저장하고 있습니다. 데이터베이스는 데이터의 구조를 정의하고, 새로운 데이터를 삽입하고, 존재하는 데이터를 찾아내거나, 업데이트하거나 지우고, 데이터간 연산을 수행하는 등의 역할을 수행합니다. 추가로, 각각의 백엔드 서비스는 대개 자신만의 독립적인 데이터베이스를 가집니다.

아키텍쳐의 각 컴포넌트에 대해 너무 깊이는 다루지 않기로 했지만, SQL과 NoSQL을 다루지 않는 것은 독자에 대한 예의가 아닌 것 같군요.

SQL은 'Structured Query Language'의 줄임말로, 1970년대 관계형 데이터를 쿼리하는 데에 표준적인 방법을 정하기 위해 개발되었습니다. SQL 데이터는 표에 데이터를 저장하고, 각 표는 공통의 ID를 통해 연결되어있습니다. 간단한 예를 들어볼까요. 유저의 주소 정보를 저장한다고 합니다. 당신은 아마도 2개의 테이블이 필요할 겁니다. user 테이블과 user_address 테이블이요. 아래 이미지를 참고해주세요. user_address 테이블의 user_id 칼럼은 user 테이블의 id 칼럼의 '외래 키'입니다. 두 테이블은 이 칼럼을 통해 서로 연결되어 있죠.
![image](__GHOST_URL__/content/images/2021/11/Untitled1.png)
만약 당신이 SQL에 대해서 잘 모른다면, [칸 아카데미](https://www.khanacademy.org/computing/computer-programming/sql) 등의 자료를 통해 학습하기를 강력히 권합니다. SQL은 모든 종류의 웹 개발에 사용되기 때문에 배워두면 굉장히 유용할겁니다.

NoSQL은 'Non-SQL'의 줄임말로, 새로운 형태의 데이터베이스 입니다. NoSQL은 거대한 스케일의 웹 어플리케이션이 생산하는 거대한 데이터를 핸들링하기 위해 만들어졌습니다. SQL은 수평적으로 확장이 쉽지 않고, 특정 지점까지만 수직적으로 확장 가능한 구조이기 때문이죠. 만약 당신이 NoSQL에 대해서 아무것도 모른다면, 아래의 하이레벨 인트로덕션부터 읽기를 권합니다.

- [https://www.w3resource.com/mongodb/nosql.php](https://www.w3resource.com/mongodb/nosql.php)
- [http://www.kdnuggets.com/2016/07/seven-steps-understanding-nosql-databases.html](http://www.kdnuggets.com/2016/07/seven-steps-understanding-nosql-databases.html)
- [https://resources.mongodb.com/getting-started-with-mongodb/back-to-basics-1-introduction-to-nosql](https://resources.mongodb.com/getting-started-with-mongodb/back-to-basics-1-introduction-to-nosql)

이미 산업계는 NoSQL 데이터베이스에 대해서도 SQL을 인터페이스로 사용하기 시작했습니다. SQL을 피할 길은 없습니다.

### 5. Caching service

캐싱 서비스는 단순한 key/value 데이터를 제공함으로써 원하는 정보를 저장하고, 찾는 데에 O(1)의 시간 밖에 걸리지 않도록 돕습니다. 어플리케이션은 값비싼 연산의 결과를 캐싱 서비스에 저장해두고, 요청이 들어오면 다시 연산하는 대신에, 저장된 값을 반환하는 식으로 동작합니다. 데이터 쿼리의 결과, 외부 서비스 호출, 특정 url에 대한 HTML 등을 캐싱 서비스에 저장합니다. 다음은 real world 어플리케이션의 캐싱 예시입니다.

- 구글은 특정 검색어에 대한 결과를 미리 캐시에 저장해놓습니다 '강아지', '테일러 스위프트'에 대한 검색 결과를 매번 연산하는 대신 말이죠.
- 페이스북은 당신이 로그인해서 보는 대부분의 데이터를 캐싱해놓습니다. 포스팅, 친구 등에 대한 정보를 말이죠. 페이스북의 캐싱 기술에 대해 더 자세한 아티클을 [여기](https://medium.com/@shagun/scaling-memcache-at-facebook-1ba77d71c082)에서 읽어보세요.
- Storyblocks는 서버 사이드 리액트 렌더링 결과에 해당하는 HTML과 검색 결과, typeahead 결과들을 캐싱해놓습니다.

가장 많이 사용되는 캐싱 서버 기술은 Redis와 Memcache입니다. 이 둘은 다른 포스팅에서 살펴볼게요.

### 6. Job Queue, Servers

대부분의 웹 애플리케이션은 뒷 단에서 비동기적으로 작업을 할 필요가 있습니다. 그것이 유저의 요청에 대한 응답과 직접적으로 연관이 없다면 말이죠. 예를 들어, 구글은 인터넷 전체를 크롤링하면서 인덱싱을 수행해야 합니다. 당신이 구글 검색을 했을 때 크롤링을 시작한다면 의미가 없겠죠. 대신에, 구글은 웹 서버를 비동기적으로 크롤링하며, 검색 인덱스를 업데이트 합니다.

비동기 작업을 수행하는 데 가장 널리 사용되는 아키텍쳐는 'job queue' 아키텍쳐입니다. 크게 두 가지 컴포넌트로 구분되는데요, 수행되어야하는 job들의 큐에 해당하는 부분과, 이 job들을 수행할 job server들(흔히들 worker라고 불림)입니다.

Job queue는 비동기적으로 실행되어야 할 job들의 리스트를 저장합니다. 가장 간단하게는 FIFO 형태의 큐 형태이겠지만, 대부분의 어플리케이션은 일종의 정렬을 추가한 우선순위 큐를 사용합니다. 정기적인 스케쥴이 있거나, 유저의 행동으로 인해 어떤 job이 수행되어야 할 경우, 어플리케이션은 적절한 job을 queue에 추가합니다.

Storyblocks는 우리의 마켓을 서포트하기 위해 job queue를 활용하고 있습니다. 우리는 비디오와 사진을 엔코드하고, 메타데이터 태깅을 위해 CSV를 처리하고, 유저 통계를 통합하고, 패스워드 초기화 메일을 전송하는 등의 업무를 job queue로 수행하고 있습니다. 우리는 단순한 FIFO 큐로 시작해, 우선순위 큐 모델로 업그레이드 해왔습니다. 패스워드 초기화 메일 등 빠른 처리가 필요한 operation에 대응하기 위해서 말이죠.

Job 서버는 job queue를 검사해 처리할 작업이 있는지 확인합니다. 만약 작업이 있으면, pop한 이후에 처리합니다. Job 서버를 구현하는 다양한 언어와 프레임워크가 존재하지만 이 아티클에서는 다루지 않겠습니다.

### 7. Full-text Search Service

많은 웹 어플리케이션은 자체 검색 기능을 제공합니다. 유저가 특정 텍스트 인풋을 넣으면(쿼리라고 불림), 어플리케이션은 가장 관련있는 정보를 보여주는 식이죠. 이런 종류의 기능을 지원하는 기능을 흔히 'full-text search'라고 부릅니다. Inverted index를 활용해 쿼리의 특정 키워드를 문서에서 빠르게 검색하는 방식이죠.
![image](__GHOST_URL__/content/images/2021/11/Untitled2.png)
데이터베이스에서 full-text serach를 지원하는 경우, 별도의 'search service'를 분리해 운영하는 것이 일반적입니다. 이 서버는 inverted index를 연산하고 저장하며, 쿼리 인터페이스를 제공합니다. 가장 유명한 full-text search 플랫폼은 Elasticsearch입니다. Sphinx, Apache Solr과 같은 대체재도 있습니다.

### 8. Services

앱이 특정 스케일에 다다르게 되면, 특정 서비스가 독자적인 어플리케이션으로 분리되어 나오게 됩니다. 바깥으로 드러나지는 않지만, 내부 앱이나 다른 서비스들이 상호작용하는 서버이지요. Storyblock의 경우, 다음과 같은 다양한 서비스를 가지고 있습니다.

- 계정 서비스는 사이트 전체를 통틀어 유저 데이터를 관리합니다. 이는 cross-sell opportunity를 제공하기 쉽게 만들고, 더 통합된 유저 경험을 만들어냅니다.
- 컨텐츠 서비스는 우리의 모든 비디오, 오디오, 이미지 콘텐츠의 메타데이터를 저장합니다. 또한 컨텐츠 다운로드, 다운로드 이력 등에 대한 인터페이스도 제공합니다.
- 결제 서비스는 유저의 credit card를 통한 결제 인터페이스를 제공합니다.
- HTML → PDF 서비스는 HTML을 인풋으로 받아 PDF 문서로 변환하는 인터페이스를 제공합니다.

### 9. Data

오늘날 많은 기업들은 그들이 데이터를 어떻게 다루느냐에 따라 사활이 달려있습니다. 특정 이상의 스케일에 다다른 대부분의 앱들은 데이터를 모으고, 저장하고, 분석하는 파이프라인을 개발해 사용하고 있습니다. 통상적인 데이터 파이프라인은 다음과 같은 3개의 stage로 구성됩니다.

1. 어플리케이션은 유저와의 상호작용으로 발생한 이벤트에 대한 데이터를 데이터 firehose에 전송합니다. Firehose는 데이터를 수집하고, 처리하는 스트리밍 인터페이스를 제공합니다. 대부분의 경우 raw data는 가공되어 다른 firehose로 전달됩니다. AWS kinesis와 Kafka가 가장 널리 쓰이는 툴입니다.
2. 원본 데이터와 변환된 데이터는 모두 클라우드 저장소에 저장됩니다. AWS kinesis는 firehose라는 기능을 제공하는데, 이 기능을 통해 원본 데이터를 S3 클라우드 저장소에 매우 쉽게 저장할 수 있습니다.
3. 변환된 데이터는 데이터 웨어하우스로 저장됩니다. 스타트업들의 경우 AWS redshift를, 더 큰 기업들은 Oracle이나 다른 웨어하우스 툴을 사용합니다. 분석을 진행하기에 데이터의 크기가 너무 크다면 hadoop과 같은 NoSQL map reduce 기술을 사용하는 것이 필요합니다.

아키텍쳐 다이어그램에서 다루지 않은 것은 어플리케이션과 서비스의 데이터베이스에서 데이터 웨어하우스로 데이터를 로드하는 부분입니다. 예를 들어 Storyblock의 경우, 자사의 Videoblocks, Audioblocks, 계정 서비스 등의 데이터를 매일 밤 redshift로 load하고 있습니다. 이를 통해 우리는 핵심 비즈니스 데이터를 한 곳에 모아 총체적인 분석을 진행할 수 있습니다.

### 10. Cloud Storage

AWS에 따르면, 클라우드 저장소란 인터넷을 통해 데이터를 저장하고, 접근하고, 공유하는 간편하고 scalable한 방법입니다. 당신은 RESTful API와 HTTP 프로토콜을 통해 클라우드 데이터에 접근할 수 있습니다. Amazon S3는 가장 유명한 클라우드 저장소이고, storyblocks 또한 비디오, 사진, 오디오, CSS, JS asset들을 저장하고 있습니다.

### 11. CDN

CDN은 'Content Delivery Network'의 줄임말이고, 이 기술은 서로 멀리 떨어져있는 서버 간 빠른 데이터 전송(정적 HTML, CSS, JS, etc.)을 위해 사용됩니다. CDN은 원본 서버 이외에도, 전 세계에 퍼진 edge 서버에 데이터를 분산시켜놓습니다. 예를 들어 아래의 이미지와 같이, 스페인의 유저가 뉴욕에 위치한 서버에 웹 페이지를 요청할 경우, 대서양을 횡단하는 HTTP 요청을 주고받는 대신, CDN edge 서버인 영국으로부터 전달 받게 됩니다.
![image](__GHOST_URL__/content/images/2021/11/Untitled3.png)
이 아티클을 통해 더 상세한 인트로덕션을 확인해보세요. 대개 웹 어플리케이션의 경우 CSS, JS, 이미지, 비디오 등의 에셋을 전송하기 위해 CDN을 사용합니다. 특정 앱의 경우 정적인 HTML 페이지를 제공하기 위해서도 CDN을 사용합니다.

### 마치며

이것으로 아키텍쳐 101을 마치겠습니다. 유용하게 읽으셨기를 바라며, 여기에서 다룬 기술을 더욱 상세하게 다루는 201 아티클을 내년 즈음에 작성할 수 있기를 바랍니다.
